# services/instruments/app/drivers/builtin/keithley_2400.py

“””
Keithley 2400 SourceMeter Reference Driver

Production-ready driver for Keithley 24xx series SMUs with full support for:

- I-V sweeps (forward/reverse)
- Compliance limiting
- Four-wire sensing
- Pulse measurements
- Temperature compensation

Supported Models: 2400, 2401, 2410, 2420, 2425, 2430
“””

import time
import numpy as np
from typing import Dict, Any, List, Optional, Tuple
import logging
from dataclasses import dataclass

from ..core.connection import VISAConnection, ConnectionConfig, SCPICommand
from ..core.plugin_manager import InstrumentDriver

# ============================================================================

# Configuration

# ============================================================================

@dataclass
class Keithley2400Config:
“”“Configuration for Keithley 2400”””
# Measurement
nplc: float = 1.0  # Number of power line cycles (0.01 to 10)
auto_range: bool = True
four_wire: bool = False

```
# Timing
trigger_delay: float = 0.0  # seconds
measurement_delay: float = 0.0

# Safety
max_voltage: float = 20.0  # V
max_current: float = 0.1   # A
compliance_abort: bool = True

# Advanced
autozero: bool = True
filter_enable: bool = False
filter_count: int = 10
```

# ============================================================================

# Driver Implementation

# ============================================================================

class Keithley2400Driver(InstrumentDriver):
“””
Keithley 2400 SourceMeter Driver

```
Complete implementation supporting:
- Voltage/current sourcing
- Voltage/current measurement
- Sweep operations
- Compliance protection
"""

def __init__(self, resource_name: str, config: Optional[Dict[str, Any]] = None):
    """
    Initialize Keithley 2400 driver
    
    Args:
        resource_name: VISA resource string
        config: Optional configuration dictionary
    """
    self.logger = logging.getLogger(__name__)
    self.logger.info(f"Initializing Keithley 2400 driver: {resource_name}")
    
    # Parse configuration
    if config:
        self.config = Keithley2400Config(**config)
    else:
        self.config = Keithley2400Config()
    
    # Create connection
    conn_config = ConnectionConfig(
        timeout=10.0,
        write_termination='\n',
        read_termination='\n'
    )
    self.connection = VISAConnection(resource_name, conn_config, self.logger)
    
    # State
    self._identity = None
    self._capabilities = ['iv_sweep', 'cv_measurement', 'pulse_measurement']
    self._current_source_type = None  # 'voltage' or 'current'
    self._compliance = None
    
def connect(self) -> bool:
    """Establish connection to instrument"""
    try:
        self.connection.connect()
        
        # Query identity
        idn = self.connection.query(SCPICommand.IDN)
        self._identity = SCPICommand.parse_idn(idn)
        
        # Verify it's a Keithley 24xx
        if '24' not in self._identity['model']:
            raise ValueError(f"Unsupported model: {self._identity['model']}")
        
        self.logger.info(f"Connected to {self._identity['manufacturer']} {self._identity['model']}")
        
        # Initial configuration
        self.reset()
        
        return True
        
    except Exception as e:
        self.logger.error(f"Connection failed: {e}")
        return False

def disconnect(self) -> bool:
    """Close connection to instrument"""
    try:
        # Turn off output
        self.connection.write("OUTP OFF")
        
        self.connection.disconnect()
        self.logger.info("Disconnected from Keithley 2400")
        return True
        
    except Exception as e:
        self.logger.error(f"Disconnect failed: {e}")
        return False

def reset(self) -> None:
    """Reset instrument to default state"""
    self.connection.write(SCPICommand.RST)
    time.sleep(0.5)
    
    # Configure basic settings
    self._configure_measurement()
    
    # Turn off output initially
    self.connection.write("OUTP OFF")
    
    self.logger.info("Instrument reset complete")

def get_identity(self) -> Dict[str, str]:
    """Get instrument identity"""
    if self._identity is None:
        idn = self.connection.query(SCPICommand.IDN)
        self._identity = SCPICommand.parse_idn(idn)
    return self._identity

def get_capabilities(self) -> List[str]:
    """Get list of supported methods"""
    return self._capabilities.copy()

def configure(self, method: str, params: Dict[str, Any]) -> None:
    """
    Configure instrument for a specific method
    
    Args:
        method: Method name ('iv_sweep', 'cv_measurement', etc.)
        params: Method-specific parameters
    """
    if method == 'iv_sweep':
        self._configure_iv_sweep(params)
    elif method == 'cv_measurement':
        self._configure_cv(params)
    elif method == 'pulse_measurement':
        self._configure_pulse(params)
    else:
        raise ValueError(f"Unsupported method: {method}")

def measure(self, method: str, params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Perform measurement
    
    Args:
        method: Method name
        params: Measurement parameters
    
    Returns:
        Dictionary with measurement results
    """
    if method == 'iv_sweep':
        return self._measure_iv_sweep(params)
    elif method == 'cv_measurement':
        return self._measure_cv(params)
    elif method == 'pulse_measurement':
        return self._measure_pulse(params)
    else:
        raise ValueError(f"Unsupported method: {method}")

def abort(self) -> None:
    """Abort ongoing measurement"""
    try:
        # Turn off output immediately
        self.connection.write("OUTP OFF")
        
        # Abort any triggered operations
        self.connection.write("ABOR")
        
        self.logger.info("Measurement aborted")
        
    except Exception as e:
        self.logger.error(f"Abort failed: {e}")

def get_status(self) -> Dict[str, Any]:
    """
    Get instrument status
    
    Returns:
        Dictionary with status information
    """
    try:
        # Query operation complete
        opc = self.connection.query(SCPICommand.OPC)
        
        # Query error status
        esr = self.connection.query(SCPICommand.ESR)
        
        # Check output state
        output_on = self.connection.query("OUTP?")
        
        return {
            'ready': bool(int(opc)),
            'error_status': int(esr),
            'output_enabled': bool(int(output_on)),
            'source_type': self._current_source_type,
            'compliance': self._compliance
        }
        
    except Exception as e:
        self.logger.error(f"Failed to get status: {e}")
        return {'error': str(e)}

# ========================================================================
# Private Methods - Configuration
# ========================================================================

def _configure_measurement(self) -> None:
    """Configure basic measurement settings"""
    # Set NPLC
    self.connection.write(f"SENS:CURR:NPLC {self.config.nplc}")
    self.connection.write(f"SENS:VOLT:NPLC {self.config.nplc}")
    
    # Auto-range
    if self.config.auto_range:
        self.connection.write("SENS:CURR:RANG:AUTO ON")
        self.connection.write("SENS:VOLT:RANG:AUTO ON")
    
    # Four-wire sensing
    if self.config.four_wire:
        self.connection.write("SYST:RSEN ON")
    else:
        self.connection.write("SYST:RSEN OFF")
    
    # Autozero
    if self.config.autozero:
        self.connection.write("SYST:AZER ON")
    else:
        self.connection.write("SYST:AZER OFF")
    
    # Filter
    if self.config.filter_enable:
        self.connection.write(f"SENS:AVER:COUN {self.config.filter_count}")
        self.connection.write("SENS:AVER:STAT ON")
    else:
        self.connection.write("SENS:AVER:STAT OFF")

def _configure_iv_sweep(self, params: Dict[str, Any]) -> None:
    """Configure for I-V sweep"""
    v_start = params['v_start']
    v_stop = params['v_stop']
    points = params['points']
    compliance = params.get('compliance', 0.1)  # A
    
    # Validate ranges
    if max(abs(v_start), abs(v_stop)) > self.config.max_voltage:
        raise ValueError(f"Voltage exceeds max: {self.config.max_voltage}V")
    
    if compliance > self.config.max_current:
        raise ValueError(f"Compliance exceeds max: {self.config.max_current}A")
    
    # Configure source (voltage)
    self.connection.write("SOUR:FUNC VOLT")
    self.connection.write(f"SOUR:VOLT:START {v_start}")
    self.connection.write(f"SOUR:VOLT:STOP {v_stop}")
    self.connection.write(f"SOUR:VOLT:POIN {points}")
    self.connection.write("SOUR:VOLT:MODE SWE")
    
    # Configure measurement (current)
    self.connection.write("SENS:FUNC 'CURR'")
    self.connection.write(f"SENS:CURR:PROT {compliance}")
    
    # Trigger configuration
    self.connection.write("TRIG:COUN " + str(points))
    self.connection.write(f"SOUR:DEL {self.config.trigger_delay}")
    
    # Store state
    self._current_source_type = 'voltage'
    self._compliance = compliance
    
    self.logger.info(f"Configured I-V sweep: {v_start}V to {v_stop}V, {points} points, {compliance}A compliance")

def _configure_cv(self, params: Dict[str, Any]) -> None:
    """Configure for C-V measurement"""
    # This requires LCR-style measurements
    # Simplified version for demo
    raise NotImplementedError("C-V measurement requires LCR capability (available on 4200-SCS)")

def _configure_pulse(self, params: Dict[str, Any]) -> None:
    """Configure for pulse measurement"""
    raise NotImplementedError("Pulse measurement requires pulse card (available on 4200-SCS)")

# ========================================================================
# Private Methods - Measurement
# ========================================================================

def _measure_iv_sweep(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Perform I-V sweep measurement
    
    Returns:
        Dictionary with voltage, current arrays and metadata
    """
    start_time = time.time()
    
    try:
        # Enable output
        self.connection.write("OUTP ON")
        time.sleep(0.1)
        
        # Initiate sweep
        self.connection.write("INIT")
        
        # Wait for completion
        points = int(self.connection.query("TRIG:COUN?"))
        
        # Estimate sweep time
        estimated_time = points * (self.config.nplc * 0.02 + self.config.trigger_delay + 0.01)
        self.logger.info(f"Estimated sweep time: {estimated_time:.1f}s")
        
        # Poll for completion
        timeout = estimated_time + 5.0
        start = time.time()
        while True:
            opc = self.connection.query(SCPICommand.OPC)
            if int(opc) == 1:
                break
            
            if time.time() - start > timeout:
                raise TimeoutError(f"Sweep timeout after {timeout}s")
            
            time.sleep(0.5)
        
        # Read data
        self.connection.write("FORM:ELEM VOLT,CURR,RES,TIME,STAT")
        data_str = self.connection.query("FETC?")
        
        # Parse data
        values = [float(x) for x in data_str.split(',')]
        num_points = len(values) // 5
        
        voltage = np.array([values[i*5] for i in range(num_points)])
        current = np.array([values[i*5 + 1] for i in range(num_points)])
        resistance = np.array([values[i*5 + 2] for i in range(num_points)])
        timestamp = np.array([values[i*5 + 3] for i in range(num_points)])
        status = np.array([int(values[i*5 + 4]) for i in range(num_points)])
        
        # Check for compliance
        compliance_hit = np.any(status & 0x01)  # Bit 0 = compliance
        
        # Disable output
        self.connection.write("OUTP OFF")
        
        duration = time.time() - start_time
        
        return {
            'voltage': voltage.tolist(),
            'current': current.tolist(),
            'resistance': resistance.tolist(),
            'timestamp': timestamp.tolist(),
            'status': status.tolist(),
            'compliance_hit': bool(compliance_hit),
            'points_measured': num_points,
            'duration_seconds': duration,
            'metadata': {
                'instrument': self._identity,
                'source_type': 'voltage',
                'compliance': self._compliance,
                'nplc': self.config.nplc,
                'four_wire': self.config.four_wire
            }
        }
        
    except Exception as e:
        # Emergency: turn off output
        try:
            self.connection.write("OUTP OFF")
        except:
            pass
        
        self.logger.error(f"I-V sweep failed: {e}")
        raise

def _measure_cv(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """Perform C-V measurement"""
    raise NotImplementedError("C-V measurement not available on this model")

def _measure_pulse(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """Perform pulse measurement"""
    raise NotImplementedError("Pulse measurement not available on this model")

# ========================================================================
# Utility Methods
# ========================================================================

def set_voltage(self, voltage: float, compliance: float = 0.1) -> None:
    """
    Set constant voltage output
    
    Args:
        voltage: Voltage in volts
        compliance: Current compliance in amps
    """
    if abs(voltage) > self.config.max_voltage:
        raise ValueError(f"Voltage exceeds max: {self.config.max_voltage}V")
    
    self.connection.write("SOUR:FUNC VOLT")
    self.connection.write(f"SOUR:VOLT {voltage}")
    self.connection.write(f"SENS:CURR:PROT {compliance}")
    self.connection.write("OUTP ON")
    
    self._current_source_type = 'voltage'
    self._compliance = compliance

def measure_current(self) -> float:
    """
    Measure current
    
    Returns:
        Current in amps
    """
    self.connection.write("SENS:FUNC 'CURR'")
    response = self.connection.query("READ?")
    return float(response)

def set_current(self, current: float, compliance: float = 20.0) -> None:
    """
    Set constant current output
    
    Args:
        current: Current in amps
        compliance: Voltage compliance in volts
    """
    if abs(current) > self.config.max_current:
        raise ValueError(f"Current exceeds max: {self.config.max_current}A")
    
    self.connection.write("SOUR:FUNC CURR")
    self.connection.write(f"SOUR:CURR {current}")
    self.connection.write(f"SENS:VOLT:PROT {compliance}")
    self.connection.write("OUTP ON")
    
    self._current_source_type = 'current'
    self._compliance = compliance

def measure_voltage(self) -> float:
    """
    Measure voltage
    
    Returns:
        Voltage in volts
    """
    self.connection.write("SENS:FUNC 'VOLT'")
    response = self.connection.query("READ?")
    return float(response)
```

# ============================================================================

# Example Usage & Testing

# ============================================================================

def example_usage():
“”“Demonstrate Keithley 2400 driver”””
print(”=” * 80)
print(“Keithley 2400 Driver - Example Usage”)
print(”=” * 80)

```
print("\n1. Driver Initialization:")
print("   driver = Keithley2400Driver('USB0::0x05E6::0x2400::...', config)")
print("   driver.connect()")

print("\n2. I-V Sweep Configuration:")
print("   params = {")
print("       'v_start': 0.0,")
print("       'v_stop': 1.0,")
print("       'points': 100,")
print("       'compliance': 0.1")
print("   }")
print("   driver.configure('iv_sweep', params)")

print("\n3. Measurement:")
print("   results = driver.measure('iv_sweep', params)")
print("   voltage = results['voltage']")
print("   current = results['current']")

print("\n4. Simple Operations:")
print("   driver.set_voltage(0.6, compliance=0.01)")
print("   i = driver.measure_current()")

print("\n" + "=" * 80)
print("Keithley 2400 driver demonstration complete!")
print("=" * 80)
```

if **name** == “**main**”:
logging.basicConfig(level=logging.INFO)
example_usage()