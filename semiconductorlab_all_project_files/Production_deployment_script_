# ============================================================================

# Production Deployment Package

# Complete scripts for deploying SemiconductorLab to production

# ============================================================================

-----

# File 1: docker-compose.prod.yml

# Production-grade Docker Compose configuration

version: â€˜3.8â€™

services:

# ===== Frontend =====

web:
image: semiconductorlab/web:${VERSION:-latest}
build:
context: ./apps/web
dockerfile: Dockerfile.prod
args:
NODE_ENV: production
ports:
- â€œ80:3000â€
- â€œ443:3000â€
environment:
- NODE_ENV=production
- NEXT_PUBLIC_API_URL=https://api.semiconductorlab.com
- NEXT_TELEMETRY_DISABLED=1
depends_on:
- api-gateway
restart: unless-stopped
healthcheck:
test: [â€œCMDâ€, â€œcurlâ€, â€œ-fâ€, â€œhttp://localhost:3000/api/healthâ€]
interval: 30s
timeout: 10s
retries: 3
deploy:
replicas: 2
resources:
limits:
cpus: â€˜1.0â€™
memory: 1G
reservations:
cpus: â€˜0.5â€™
memory: 512M

# ===== API Gateway =====

api-gateway:
image: semiconductorlab/api-gateway:${VERSION:-latest}
build:
context: ./services/api-gateway
dockerfile: Dockerfile.prod
ports:
- â€œ8000:8000â€
environment:
- DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/semiconductorlab
- REDIS_URL=redis://redis:6379/0
- JWT_SECRET=${JWT_SECRET}
- CORS_ORIGINS=https://semiconductorlab.com,https://www.semiconductorlab.com
- LOG_LEVEL=INFO
depends_on:
- postgres
- redis
restart: unless-stopped
healthcheck:
test: [â€œCMDâ€, â€œcurlâ€, â€œ-fâ€, â€œhttp://localhost:8000/healthâ€]
interval: 30s
timeout: 10s
retries: 3
deploy:
replicas: 2
resources:
limits:
cpus: â€˜2.0â€™
memory: 2G

# ===== Instruments Service =====

instruments:
image: semiconductorlab/instruments:${VERSION:-latest}
build:
context: ./services/instruments
dockerfile: Dockerfile.prod
ports:
- â€œ8001:8000â€
environment:
- DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/semiconductorlab
- REDIS_URL=redis://redis:6379/1
- NATS_URL=nats://nats:4222
- S3_ENDPOINT=${S3_ENDPOINT}
- S3_ACCESS_KEY=${S3_ACCESS_KEY}
- S3_SECRET_KEY=${S3_SECRET_KEY}
- LOG_LEVEL=INFO
depends_on:
- postgres
- redis
- nats
- minio
restart: unless-stopped
devices:
- â€œ/dev/usbtmc0:/dev/usbtmc0â€  # USBTMC devices
privileged: true  # Required for instrument access
deploy:
replicas: 1  # Single instance for instrument control
resources:
limits:
cpus: â€˜1.0â€™
memory: 1G

# ===== Analysis Service =====

analysis:
image: semiconductorlab/analysis:${VERSION:-latest}
build:
context: ./services/analysis
dockerfile: Dockerfile.prod
ports:
- â€œ8002:8000â€
environment:
- DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/semiconductorlab
- REDIS_URL=redis://redis:6379/2
- NATS_URL=nats://nats:4222
- S3_ENDPOINT=${S3_ENDPOINT}
- S3_ACCESS_KEY=${S3_ACCESS_KEY}
- S3_SECRET_KEY=${S3_SECRET_KEY}
- CELERY_BROKER_URL=redis://redis:6379/3
- LOG_LEVEL=INFO
depends_on:
- postgres
- redis
- nats
- minio
restart: unless-stopped
deploy:
replicas: 3
resources:
limits:
cpus: â€˜4.0â€™
memory: 8G

# ===== Celery Workers =====

celery-worker:
image: semiconductorlab/analysis:${VERSION:-latest}
command: celery -A app.workers worker â€“loglevel=info â€“concurrency=4
environment:
- DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/semiconductorlab
- REDIS_URL=redis://redis:6379/2
- CELERY_BROKER_URL=redis://redis:6379/3
- S3_ENDPOINT=${S3_ENDPOINT}
- S3_ACCESS_KEY=${S3_ACCESS_KEY}
- S3_SECRET_KEY=${S3_SECRET_KEY}
depends_on:
- postgres
- redis
- minio
restart: unless-stopped
deploy:
replicas: 2
resources:
limits:
cpus: â€˜4.0â€™
memory: 8G

# ===== PostgreSQL + TimescaleDB =====

postgres:
image: timescale/timescaledb:latest-pg15
ports:
- â€œ5432:5432â€
environment:
- POSTGRES_DB=semiconductorlab
- POSTGRES_USER=postgres
- POSTGRES_PASSWORD=${DB_PASSWORD}
- PGDATA=/var/lib/postgresql/data/pgdata
volumes:
- postgres-data:/var/lib/postgresql/data
- ./db/migrations:/docker-entrypoint-initdb.d
restart: unless-stopped
healthcheck:
test: [â€œCMD-SHELLâ€, â€œpg_isready -U postgresâ€]
interval: 10s
timeout: 5s
retries: 5
deploy:
resources:
limits:
cpus: â€˜4.0â€™
memory: 8G

# ===== Redis =====

redis:
image: redis:7-alpine
ports:
- â€œ6379:6379â€
command: redis-server â€“appendonly yes â€“requirepass ${REDIS_PASSWORD}
volumes:
- redis-data:/data
restart: unless-stopped
healthcheck:
test: [â€œCMDâ€, â€œredis-cliâ€, â€œpingâ€]
interval: 10s
timeout: 5s
retries: 5

# ===== NATS =====

nats:
image: nats:latest
ports:
- â€œ4222:4222â€
- â€œ8222:8222â€
command: â€œâ€“jetstream â€“store_dir=/dataâ€
volumes:
- nats-data:/data
restart: unless-stopped
healthcheck:
test: [â€œCMDâ€, â€œwgetâ€, â€œâ€“spiderâ€, â€œhttp://localhost:8222/healthzâ€]
interval: 10s
timeout: 5s
retries: 5

# ===== MinIO (S3-compatible storage) =====

minio:
image: minio/minio:latest
ports:
- â€œ9000:9000â€
- â€œ9001:9001â€
environment:
- MINIO_ROOT_USER=${S3_ACCESS_KEY}
- MINIO_ROOT_PASSWORD=${S3_SECRET_KEY}
volumes:
- minio-data:/data
command: server /data â€“console-address â€œ:9001â€
restart: unless-stopped
healthcheck:
test: [â€œCMDâ€, â€œcurlâ€, â€œ-fâ€, â€œhttp://localhost:9000/minio/health/liveâ€]
interval: 30s
timeout: 10s
retries: 3

# ===== Prometheus =====

prometheus:
image: prom/prometheus:latest
ports:
- â€œ9090:9090â€
volumes:
- ./infra/monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
- prometheus-data:/prometheus
command:
- â€˜â€“config.file=/etc/prometheus/prometheus.ymlâ€™
- â€˜â€“storage.tsdb.path=/prometheusâ€™
- â€˜â€“storage.tsdb.retention.time=30dâ€™
restart: unless-stopped

# ===== Grafana =====

grafana:
image: grafana/grafana:latest
ports:
- â€œ3001:3000â€
environment:
- GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
- GF_INSTALL_PLUGINS=grafana-clock-panel
volumes:
- ./infra/monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards
- grafana-data:/var/lib/grafana
depends_on:
- prometheus
restart: unless-stopped

# ===== Loki (Log Aggregation) =====

loki:
image: grafana/loki:latest
ports:
- â€œ3100:3100â€
volumes:
- ./infra/monitoring/loki/loki-config.yml:/etc/loki/config.yml
- loki-data:/loki
command: -config.file=/etc/loki/config.yml
restart: unless-stopped

volumes:
postgres-data:
driver: local
redis-data:
driver: local
nats-data:
driver: local
minio-data:
driver: local
prometheus-data:
driver: local
grafana-data:
driver: local
loki-data:
driver: local

networks:
default:
driver: bridge

-----

# File 2: .env.production.example

# Production environment variables template

# Application

VERSION=1.0.0
NODE_ENV=production
LOG_LEVEL=INFO

# Database

DB_PASSWORD=CHANGE_ME_SECURE_PASSWORD
DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/semiconductorlab

# Redis

REDIS_PASSWORD=CHANGE_ME_REDIS_PASSWORD
REDIS_URL=redis://redis:6379/0

# S3/MinIO

S3_ENDPOINT=http://minio:9000
S3_ACCESS_KEY=CHANGE_ME_MINIO_ACCESS_KEY
S3_SECRET_KEY=CHANGE_ME_MINIO_SECRET_KEY

# JWT

JWT_SECRET=CHANGE_ME_JWT_SECRET_AT_LEAST_32_CHARS

# Grafana

GRAFANA_PASSWORD=CHANGE_ME_GRAFANA_PASSWORD

# CORS

CORS_ORIGINS=https://semiconductorlab.com,https://www.semiconductorlab.com

# Email (for notifications)

SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=notifications@semiconductorlab.com
SMTP_PASSWORD=CHANGE_ME_SMTP_PASSWORD

-----

# File 3: Makefile.prod

# Production deployment commands

.PHONY: deploy health logs backup restore scale

# Deploy to production

deploy:
@echo â€œğŸš€ Deploying SemiconductorLab to productionâ€¦â€
@read -p â€œHave you reviewed the changes? (yes/no): â€œ confirm && [ â€œ$$confirmâ€ = â€œyesâ€ ] || exit 1
docker-compose -f docker-compose.prod.yml pull
docker-compose -f docker-compose.prod.yml up -d â€“remove-orphans
@echo â€œâœ“ Deployment completeâ€
@echo â€œRunning health checksâ€¦â€
@make health

# Health check all services

health:
@echo â€œğŸ¥ Checking service healthâ€¦â€
@docker-compose -f docker-compose.prod.yml ps
@curl -f http://localhost:3000/api/health || echo â€œâŒ Web health check failedâ€
@curl -f http://localhost:8000/health || echo â€œâŒ API Gateway health check failedâ€
@curl -f http://localhost:8001/health || echo â€œâŒ Instruments health check failedâ€
@curl -f http://localhost:8002/health || echo â€œâŒ Analysis health check failedâ€
@echo â€œâœ“ Health checks completeâ€

# View logs

logs:
docker-compose -f docker-compose.prod.yml logs -f â€“tail=100

# Backup database

backup:
@echo â€œğŸ’¾ Creating database backupâ€¦â€
@mkdir -p backups
@TIMESTAMP=$$(date +%Y%m%d_%H%M%S) &&   
docker-compose -f docker-compose.prod.yml exec -T postgres   
pg_dump -U postgres semiconductorlab | gzip > backups/db_$$TIMESTAMP.sql.gz
@echo â€œâœ“ Backup created: backups/db_$$TIMESTAMP.sql.gzâ€

# Restore database

restore:
@echo â€œâš ï¸  WARNING: This will restore the database from backupâ€
@read -p â€œEnter backup filename (e.g., db_20250101_120000.sql.gz): â€œ filename &&   
gunzip -c backups/$$filename |   
docker-compose -f docker-compose.prod.yml exec -T postgres   
psql -U postgres semiconductorlab
@echo â€œâœ“ Database restoredâ€

# Scale services

scale-analysis:
docker-compose -f docker-compose.prod.yml up -d â€“scale analysis=5 â€“no-recreate

scale-workers:
docker-compose -f docker-compose.prod.yml up -d â€“scale celery-worker=4 â€“no-recreate

# Rolling restart

rolling-restart:
@echo â€œğŸ”„ Performing rolling restartâ€¦â€
@for service in web api-gateway instruments analysis; do   
echo â€œRestarting $$serviceâ€¦â€;   
docker-compose -f docker-compose.prod.yml restart $$service;   
sleep 10;   
done
@echo â€œâœ“ Rolling restart completeâ€

# Stop all services

stop:
docker-compose -f docker-compose.prod.yml stop

# Clean up

clean:
@echo â€œâš ï¸  WARNING: This will remove all containers and volumesâ€
@read -p â€œAre you sure? (yes/no): â€œ confirm && [ â€œ$$confirmâ€ = â€œyesâ€ ] || exit 1
docker-compose -f docker-compose.prod.yml down -v
@echo â€œâœ“ Cleanup completeâ€

-----

# File 4: kubernetes/deployment.yaml

# Kubernetes production deployment (alternative to Docker Compose)

apiVersion: apps/v1
kind: Deployment
metadata:
name: semiconductorlab-web
namespace: semiconductorlab
spec:
replicas: 3
selector:
matchLabels:
app: web
template:
metadata:
labels:
app: web
spec:
containers:
- name: web
image: semiconductorlab/web:latest
ports:
- containerPort: 3000
env:
- name: NODE_ENV
value: â€œproductionâ€
- name: NEXT_PUBLIC_API_URL
valueFrom:
configMapKeyRef:
name: app-config
key: api-url
resources:
requests:
memory: â€œ512Miâ€
cpu: â€œ500mâ€
limits:
memory: â€œ1Giâ€
cpu: â€œ1000mâ€
livenessProbe:
httpGet:
path: /api/health
port: 3000
initialDelaySeconds: 30
periodSeconds: 10
readinessProbe:
httpGet:
path: /api/health
port: 3000
initialDelaySeconds: 5
periodSeconds: 5

-----

apiVersion: apps/v1
kind: Deployment
metadata:
name: semiconductorlab-api
namespace: semiconductorlab
spec:
replicas: 2
selector:
matchLabels:
app: api
template:
metadata:
labels:
app: api
spec:
containers:
- name: api
image: semiconductorlab/api-gateway:latest
ports:
- containerPort: 8000
env:
- name: DATABASE_URL
valueFrom:
secretKeyRef:
name: db-secret
key: connection-string
- name: JWT_SECRET
valueFrom:
secretKeyRef:
name: jwt-secret
key: token
resources:
requests:
memory: â€œ1Giâ€
cpu: â€œ1000mâ€
limits:
memory: â€œ2Giâ€
cpu: â€œ2000mâ€

-----

# File 5: CI/CD Pipeline - .github/workflows/deploy-production.yml

name: Deploy to Production

on:
push:
tags:
- â€˜v*.*.*â€™

jobs:
test:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v3

```
  - name: Run tests
    run: |
      docker-compose -f docker-compose.test.yml up --abort-on-container-exit
      docker-compose -f docker-compose.test.yml down
  
  - name: Check test results
    run: |
      if [ $? -ne 0 ]; then
        echo "Tests failed"
        exit 1
      fi
```

build-and-push:
needs: test
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v3

```
  - name: Set up Docker Buildx
    uses: docker/setup-buildx-action@v2
  
  - name: Login to Docker Hub
    uses: docker/login-action@v2
    with:
      username: ${{ secrets.DOCKER_USERNAME }}
      password: ${{ secrets.DOCKER_PASSWORD }}
  
  - name: Extract version
    id: version
    run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
  
  - name: Build and push
    run: |
      docker-compose -f docker-compose.prod.yml build
      docker-compose -f docker-compose.prod.yml push
```

deploy:
needs: build-and-push
runs-on: ubuntu-latest
steps:
- name: Deploy to production
uses: appleboy/ssh-action@master
with:
host: ${{ secrets.PROD_SERVER_HOST }}
username: ${{ secrets.PROD_SERVER_USER }}
key: ${{ secrets.PROD_SERVER_SSH_KEY }}
script: |
cd /opt/semiconductorlab
git pull origin main
make deploy
make health

-----

# File 6: scripts/ops/deploy-production.sh

# Manual deployment script

#!/bin/bash
set -e

echo â€œ=========================================â€
echo â€œSemiconductorLab Production Deploymentâ€
echo â€œ=========================================â€

# Check prerequisites

command -v docker >/dev/null 2>&1 || { echo â€œDocker is required but not installedâ€; exit 1; }
command -v docker-compose >/dev/null 2>&1 || { echo â€œDocker Compose is requiredâ€; exit 1; }

# Load environment

if [ ! -f .env.production ]; then
echo â€œâŒ .env.production not foundâ€
echo â€œCopy .env.production.example and configure itâ€
exit 1
fi

source .env.production

# Validate critical env vars

if [ -z â€œ$DB_PASSWORDâ€ ] || [ â€œ$DB_PASSWORDâ€ = â€œCHANGE_ME_SECURE_PASSWORDâ€ ]; then
echo â€œâŒ DB_PASSWORD not configured in .env.productionâ€
exit 1
fi

if [ -z â€œ$JWT_SECRETâ€ ] || [ â€œ$JWT_SECRETâ€ = â€œCHANGE_ME_JWT_SECRET_AT_LEAST_32_CHARSâ€ ]; then
echo â€œâŒ JWT_SECRET not configured in .env.productionâ€
exit 1
fi

# Confirm deployment

read -p â€œDeploy version ${VERSION:-latest} to production? (yes/no): â€œ confirm
if [ â€œ$confirmâ€ != â€œyesâ€ ]; then
echo â€œDeployment cancelledâ€
exit 0
fi

# Backup database

echo â€œğŸ“¦ Creating backupâ€¦â€
make -f Makefile.prod backup

# Pull latest images

echo â€œğŸ“¥ Pulling latest imagesâ€¦â€
docker-compose -f docker-compose.prod.yml pull

# Deploy

echo â€œğŸš€ Deployingâ€¦â€
docker-compose -f docker-compose.prod.yml up -d â€“remove-orphans

# Wait for services

echo â€œâ³ Waiting for services to startâ€¦â€
sleep 30

# Health check

echo â€œğŸ¥ Running health checksâ€¦â€
make -f Makefile.prod health

echo â€œâ€
echo â€œ=========================================â€
echo â€œâœ… Deployment complete!â€
echo â€œ=========================================â€
echo â€œâ€
echo â€œServices:â€
echo â€œ  Web UI:    http://localhostâ€
echo â€œ  API:       http://localhost:8000â€
echo â€œ  Grafana:   http://localhost:3001â€
echo â€œ  MinIO:     http://localhost:9001â€
echo â€œâ€
echo â€œNext steps:â€
echo â€œ  - View logs:    make -f Makefile.prod logsâ€
echo â€œ  - Monitor:      http://localhost:3001â€
echo â€œ  - Scale up:     make -f Makefile.prod scale-analysisâ€
echo â€œâ€