# services/instruments/app/simulators/base_simulator.py

“””
Base Hardware-in-the-Loop (HIL) Simulator Framework
Provides physics-based instrument simulators for development and testing
“””

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from enum import Enum
import numpy as np
import time

class InstrumentState(Enum):
“”“Instrument connection states”””
DISCONNECTED = “disconnected”
CONNECTED = “connected”
MEASURING = “measuring”
ERROR = “error”

@dataclass
class SimulatorConfig:
“”“Configuration for simulator behavior”””
# Noise characteristics
add_noise: bool = True
johnson_noise_density: float = 1e-10  # A/√Hz
flicker_noise_corner: float = 100.0  # Hz

```
# Instrument artifacts
add_quantization: bool = True
adc_bits: int = 16
adc_range: float = 10.0  # Volts or Amps

# Timing
response_delay: float = 0.01  # seconds per measurement
settling_time: float = 0.001  # seconds

# Drift and instability
add_drift: bool = False
drift_rate: float = 1e-6  # units per second
temperature_coeff: float = 0.0001  # per °C
```

class BaseSimulator(ABC):
“””
Abstract base class for instrument simulators

```
All simulators must implement:
- connect(): Establish virtual connection
- disconnect(): Close virtual connection
- reset(): Reset to initial state
- get_identity(): Return instrument ID string
- measure(): Perform a measurement
"""

def __init__(self, config: Optional[SimulatorConfig] = None):
    self.config = config or SimulatorConfig()
    self.state = InstrumentState.DISCONNECTED
    self.start_time = time.time()
    self._measurement_count = 0
    
@abstractmethod
def connect(self) -> bool:
    """Establish virtual connection to instrument"""
    pass

@abstractmethod
def disconnect(self) -> bool:
    """Close virtual connection"""
    pass

@abstractmethod
def reset(self) -> None:
    """Reset instrument to initial state"""
    pass

@abstractmethod
def get_identity(self) -> str:
    """Return instrument identification string"""
    pass

@abstractmethod
def measure(self, **params) -> Dict[str, Any]:
    """Perform a measurement with given parameters"""
    pass

def add_noise(self, signal: np.ndarray, frequency: float = 1000.0) -> np.ndarray:
    """
    Add realistic noise to signal
    
    Args:
        signal: Clean signal array
        frequency: Measurement frequency (Hz)
        
    Returns:
        Noisy signal
    """
    if not self.config.add_noise:
        return signal
        
    # Johnson (thermal) noise - white noise
    johnson = np.random.normal(0, self.config.johnson_noise_density * np.sqrt(frequency), signal.shape)
    
    # 1/f (flicker) noise
    if frequency < self.config.flicker_noise_corner:
        flicker_amplitude = self.config.johnson_noise_density * np.sqrt(self.config.flicker_noise_corner / frequency)
        flicker = np.random.normal(0, flicker_amplitude, signal.shape)
    else:
        flicker = 0
        
    return signal + johnson + flicker

def quantize(self, signal: np.ndarray) -> np.ndarray:
    """Apply ADC quantization"""
    if not self.config.add_quantization:
        return signal
        
    levels = 2 ** self.config.adc_bits
    lsb = self.config.adc_range / levels
    
    # Clip to range
    signal = np.clip(signal, -self.config.adc_range/2, self.config.adc_range/2)
    
    # Quantize
    quantized = np.round(signal / lsb) * lsb
    
    return quantized

def apply_drift(self, signal: float) -> float:
    """Apply temporal drift"""
    if not self.config.add_drift:
        return signal
        
    elapsed = time.time() - self.start_time
    drift = self.config.drift_rate * elapsed
    
    return signal + drift

def simulate_delay(self) -> None:
    """Simulate instrument response time"""
    time.sleep(self.config.response_delay)
```

# ============================================================================

# Diode I-V Simulator

# ============================================================================

@dataclass
class DiodeParams:
“”“Diode model parameters”””
Is: float = 1e-12  # Saturation current (A)
n: float = 1.5     # Ideality factor
Rs: float = 10.0   # Series resistance (Ω)
Rsh: float = 1e6   # Shunt resistance (Ω)
T: float = 300.0   # Temperature (K)
Vbr: float = -50.0 # Breakdown voltage (V)
Ibr: float = 1e-6  # Breakdown current (A)

class DiodeIVSimulator(BaseSimulator):
“””
Physics-based diode I-V simulator using Shockley equation

```
Models:
- Forward conduction (Shockley equation)
- Series and shunt resistance
- Reverse breakdown
- Temperature dependence
- Realistic noise and quantization

Example usage:
    sim = DiodeIVSimulator()
    sim.connect()
    result = sim.sweep_iv(v_start=-1.0, v_stop=1.0, points=100)
    sim.disconnect()
"""

def __init__(self, params: Optional[DiodeParams] = None, config: Optional[SimulatorConfig] = None):
    super().__init__(config)
    self.params = params or DiodeParams()
    
    # Physical constants
    self.k = 1.380649e-23  # Boltzmann constant (J/K)
    self.q = 1.602176634e-19  # Elementary charge (C)
    
    # Calculate thermal voltage
    self.Vt = (self.k * self.params.T) / self.q  # ~26 mV at 300K
    
def connect(self) -> bool:
    """Connect to simulated diode"""
    self.state = InstrumentState.CONNECTED
    self.start_time = time.time()
    return True

def disconnect(self) -> bool:
    """Disconnect from simulated diode"""
    self.state = InstrumentState.DISCONNECTED
    return True

def reset(self) -> None:
    """Reset simulator"""
    self._measurement_count = 0
    self.start_time = time.time()

def get_identity(self) -> str:
    """Return identification string"""
    return "SEMICONDUCTORLAB,DIODE_SIMULATOR,SN12345,v1.0.0"

def _diode_current_ideal(self, Vd: float) -> float:
    """
    Calculate ideal diode current using Shockley equation
    
    I = Is * (exp(Vd / (n*Vt)) - 1)
    """
    # Prevent overflow for large forward voltages
    exponent = Vd / (self.params.n * self.Vt)
    if exponent > 50:
        # Approximate for large forward bias
        return self.params.Is * np.exp(50) * np.exp(exponent - 50)
    
    return self.params.Is * (np.exp(exponent) - 1)

def _diode_current_with_resistances(self, Vappl: float) -> float:
    """
    Calculate diode current including series and shunt resistance
    Uses Newton-Raphson iteration to solve implicit equation
    """
    # Initial guess
    I = self._diode_current_ideal(Vappl)
    
    # Newton-Raphson iteration
    for _ in range(10):
        Vd = Vappl - I * self.params.Rs
        Id = self._diode_current_ideal(Vd)
        Ish = Vd / self.params.Rsh
        
        f = I - Id - Ish
        
        # Derivative
        dId_dVd = (self.params.Is / (self.params.n * self.Vt)) * np.exp(Vd / (self.params.n * self.Vt))
        df_dI = 1 + self.params.Rs * (dId_dVd + 1 / self.params.Rsh)
        
        # Update
        I_new = I - f / df_dI
        
        if abs(I_new - I) < 1e-15:
            break
            
        I = I_new
    
    return I

def _add_breakdown(self, V: float, I: float) -> float:
    """Add reverse breakdown behavior"""
    if V < self.params.Vbr:
        # Exponential breakdown model
        breakdown_factor = np.exp((self.params.Vbr - V) / 0.1)
        I = I - self.params.Ibr * breakdown_factor
    
    return I

def measure(self, voltage: float) -> Dict[str, Any]:
    """
    Measure current at given applied voltage
    
    Args:
        voltage: Applied voltage (V)
        
    Returns:
        Dictionary with voltage, current, and metadata
    """
    if self.state != InstrumentState.CONNECTED:
        raise RuntimeError("Simulator not connected")
    
    self.state = InstrumentState.MEASURING
    self.simulate_delay()
    
    # Calculate ideal current
    current = self._diode_current_with_resistances(voltage)
    
    # Add breakdown
    current = self._add_breakdown(voltage, current)
    
    # Add drift
    current = self.apply_drift(current)
    
    # Add noise
    current_noisy = self.add_noise(np.array([current]), frequency=1000.0)[0]
    
    # Quantize
    current_quantized = self.quantize(np.array([current_noisy]))[0]
    
    self._measurement_count += 1
    self.state = InstrumentState.CONNECTED
    
    return {
        "voltage": voltage,
        "current": float(current_quantized),
        "timestamp": time.time(),
        "measurement_number": self._measurement_count
    }

def sweep_iv(self, v_start: float, v_stop: float, points: int, 
             compliance: float = 0.1) -> Dict[str, Any]:
    """
    Perform I-V sweep
    
    Args:
        v_start: Start voltage (V)
        v_stop: Stop voltage (V)
        points: Number of points
        compliance: Current compliance limit (A)
        
    Returns:
        Dictionary with voltage and current arrays
    """
    if self.state != InstrumentState.CONNECTED:
        raise RuntimeError("Simulator not connected")
    
    voltages = np.linspace(v_start, v_stop, points)
    currents = []
    
    for V in voltages:
        result = self.measure(V)
        I = result["current"]
        
        # Check compliance
        if abs(I) > compliance:
            print(f"Warning: Compliance limit reached at V={V:.3f}V")
            break
            
        currents.append(I)
    
    return {
        "voltage": voltages[:len(currents)].tolist(),
        "current": currents,
        "points": len(currents),
        "compliance": compliance,
        "params": {
            "Is": self.params.Is,
            "n": self.params.n,
            "Rs": self.params.Rs,
            "Rsh": self.params.Rsh,
            "T": self.params.T
        }
    }
```

# ============================================================================

# Example Usage & Testing

# ============================================================================

def example_usage():
“”“Demonstrate diode simulator usage”””
print(”=” * 80)
print(“Diode I-V Simulator - Example Usage”)
print(”=” * 80)

```
# Create simulator with custom parameters
diode_params = DiodeParams(
    Is=1e-12,    # 1 pA saturation current
    n=1.5,       # Ideality factor
    Rs=10.0,     # 10 Ω series resistance
    Rsh=1e6,     # 1 MΩ shunt resistance
    T=300.0      # 300 K (room temperature)
)

sim_config = SimulatorConfig(
    add_noise=True,
    add_quantization=True,
    adc_bits=16,
    response_delay=0.001  # 1 ms per point
)

sim = DiodeIVSimulator(params=diode_params, config=sim_config)

# Connect
print("\n1. Connecting to simulator...")
sim.connect()
print(f"   Identity: {sim.get_identity()}")

# Single point measurement
print("\n2. Single point measurement at 0.6V:")
result = sim.measure(voltage=0.6)
print(f"   Voltage: {result['voltage']:.3f} V")
print(f"   Current: {result['current']:.6e} A")

# Forward sweep
print("\n3. Forward I-V sweep (0V to 0.8V, 100 points):")
start = time.time()
data = sim.sweep_iv(v_start=0.0, v_stop=0.8, points=100, compliance=0.1)
elapsed = time.time() - start

print(f"   Points acquired: {data['points']}")
print(f"   Voltage range: {min(data['voltage']):.3f}V to {max(data['voltage']):.3f}V")
print(f"   Current range: {min(data['current']):.3e}A to {max(data['current']):.3e}A")
print(f"   Acquisition time: {elapsed:.2f}s")
print(f"   Throughput: {data['points']/elapsed:.1f} points/sec")

# Extract parameters (simulate curve fitting)
print("\n4. Simulated parameter extraction:")
print(f"   Is (saturation current): {diode_params.Is:.3e} A")
print(f"   n (ideality factor): {diode_params.n:.2f}")
print(f"   Rs (series resistance): {diode_params.Rs:.1f} Ω")

# Reverse sweep
print("\n5. Reverse I-V sweep (-1V to 0V, 50 points):")
data_reverse = sim.sweep_iv(v_start=-1.0, v_stop=0.0, points=50)
print(f"   Points acquired: {data_reverse['points']}")
print(f"   Leakage current at -1V: {data_reverse['current'][0]:.3e} A")

# Disconnect
print("\n6. Disconnecting...")
sim.disconnect()
print("   Done!")

print("\n" + "=" * 80)
print("Simulator test completed successfully!")
print("=" * 80)
```

def validation_test():
“”“Validate simulator against known values”””
print(”\nValidation Test:”)
print(”-” * 40)

```
# Test case: Si diode at room temperature
params = DiodeParams(Is=1e-12, n=1.0, Rs=0.0, Rsh=1e12, T=300.0)
sim = DiodeIVSimulator(params=params, config=SimulatorConfig(add_noise=False, add_quantization=False))
sim.connect()

# At 0.6V, ideal diode should have ~10 mA
result = sim.measure(voltage=0.6)

# Calculate expected current
Vt = 0.026  # ~26 mV at 300K
expected = params.Is * (np.exp(0.6 / (params.n * Vt)) - 1)

error = abs(result['current'] - expected) / expected * 100

print(f"Voltage: 0.6 V")
print(f"Expected current: {expected:.6e} A")
print(f"Simulated current: {result['current']:.6e} A")
print(f"Error: {error:.2f}%")

if error < 0.1:
    print("✓ Validation PASSED")
else:
    print("✗ Validation FAILED")

sim.disconnect()
```

if **name** == “**main**”:
# Run example
example_usage()

```
# Run validation
validation_test()
```